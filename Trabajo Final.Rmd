---
title: "R Notebook"
output: html_notebook
--- 

PROPUESTA:
DESAGREGAR LA VARIACIÓN DE PRECIOS DE LAS PROPIEDADES INMOBILIARIAS DURANTE LA PANDEMIA EN UNA UNIDAD DE ANÁLISIS VIRTUAL (MALLA HEXAGONAL)

Construir una malla hexagonal que refleje: 
    1- promedio m2 en venta 01/03/2020 - 31/03/2020
    2- promedio m2 en venta 01/03/2021 - 31/03/2021
  
  Analizar la variación de precios.
  ¿Existe algún patrón espacial claro? 


Incorporar alguna otra variable que pueda llegar a explicarlo, como: 
    - distancia al centro
    - espacios verdes
    - densidad poblacional
    
¿Hay algún tipo de correlación? Estimar 



LIBRERIAS
vroom (cargar datos rapidos)
annotator (te da que hacer cada library)
skimr (analisis estadistico rapido) ---> skimr::skim(df)



Pasos principales para esta parte:

A) CREACIÓN DE HEXÁGONOS
  - explicación creación hexágonos (Unidad de análisis virtual)
  - Creación de la malla


B) DENSIDAD: 
  - Importar radios censales 
  - Graficar por barrios
  - Disolver por hexágonos


C) USOS (SI ALCANZA EL TIEMPO): 
  - Importar RUS (releva. usos del suelo)
  - Agrupar por 5/6 categorías
  - calcular centroides de las parcelas 
  - join espacial del centroide a la malla hexagonal
  - cual es el uso predominante del hexágono?
  
  
D) DATOS TERRENOS EN VENTA (BUENOS AIRES DATA)

  DATASET TERRENOS EN VENTA 2020 (TODO EL AÑO)
  DATASET TERRENOS EN VENTA (POSPANDEMIA: 2°, 3° Y 4° TRIMESTRE 2021)
  
  - exploración de datos (skim) + grafiquitos que pinten
  - limpieza de datos. Eliminar outliers (CREAR FUNCION PARA FILTRAR OUTLIERS?)
  
  Q1-1.5*IQR
  Q3+1.5*IQR
  
Q1=quantile(df$PRECIO, c(.25))
Q3=quantile(df$PRECIO, c(.75))
IQR= Q3-Q1

lim_inf=Q1-1.5*IQR
lim_sup=Q3+1.5*IQR
  
df_filter <- filter(df, PRECIO?? >lim_inf & precio_m2 < lim_sup)

Join espacial con HEXAGONOS 


crear objeto umbral:

umbral <- 4     
OJO: DETERMINAR UMBRAL. HEXÁGONOS CON MENOS INSTANCIAS QUE EL UMBRAL SE ELIMINAN/NO SE TIENEN EN CUENTA POR SESGO

Una vez que tenemos los hexágonos con 2 columnas: promedio Marzo 2020 y promedio Marzo 2021. 

mutate (VARIACION=marzo2021/marzo2020*100) 

GRAFICAR HEXÁGONOS CON PRECIOS 2020 Y 2021
GRAFICAR HEXÁGONOS CON VARIACIÓN 

INTERPRETAR


E) SI SOBRA TIEMPO, VER CORRELACIÓN. .corr (?)

 
  
  
```{r message=FALSE, warning=FALSE}
library(sf) # Simple Features for R, CRAN v1.0-1
library(tidyverse) # Easily Install and Load the 'Tidyverse', CRAN v1.3.1
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics, CRAN v3.3.5
library(skimr) # Compact and Flexible Summaries of Data, CRAN v2.1.3
library(osmdata) # Import 'OpenStreetMap' Data as Simple Features or Spatial Objects, CRAN v0.1.5 
library(annotater) # Annotate Package Load Calls, [github::luisDVA/annotater] v0.1.3
```

## Desarrollo


### Creación de hexágonos

En primer lugar vamos a descargar los barrios de CABA

```{r}
barrios_CABA <- st_read("https://cdn.buenosaires.gob.ar/datosabiertos/datasets/barrios/barrios.geojson") %>% 
  select() %>% 
  st_transform(crs = 4326)
```

Creamos la grilla hexagonal

```{r}
grid <- st_make_grid(barrios_CABA, cellsize = .01, what = "polygons", square = FALSE)

grid <- st_sf(index = 1:length(lengths(grid)), grid) %>%  #le agregamos un índice
  st_transform(crs = 4326) #mismo crs
```


Descargamos el polígono del ímite de CABA para hacer la intersercción con la grilla

```{r}
bbox_CABA_limite <- getbb("Ciudad Autónoma de Buenos Aires, Argentina", format_out = "sf_polygon")
bbox_CABA_limite <- bbox_CABA_limite$multipolygon
```

```{r}
hex <- st_intersection (bbox_CABA_limite, grid) %>% 
   st_difference()
```

Veamos cómo se ve: 

```{r}
ggplot()+
  geom_sf(data = barrios_CABA, fill="grey85", size=.8) + 
  geom_sf(data=hex, fill=NA, color="grey45")+
   labs(title="Gilla hexagonal",
        subtitle="Ciudad Autónoma de Buenos Aires")+
  theme_void()
```

Muy bien! 
Esta será nuestra Unidad de Análisis a partir de ahora. 



### Densidad poblacional

Vamos a cargar la información de radios censales provista por el GCABA

```{r}
radios <- st_read("https://cdn.buenosaires.gob.ar/datosabiertos/datasets/informacion-censal-por-radio/caba_radios_censales.geojson") %>% 
  select(-WKT) %>% 
  st_transform(crs = 4326) %>% 
  mutate(AREA=(as.integer(st_area(.)))*0.0001) %>% #calculamos el área y la convertimos en Ha
  mutate(DENSIDAD=(as.integer(TOTAL_POB))/AREA) #calculamos la densidad poblacional de cada radio censal (hab/Ha)
```
Veamos cómo queda sobre la grilla... en primer lugar, sólo superponiéndola: 

```{r}
ggplot()+
  geom_sf(data=radios, aes(fill=DENSIDAD), color=NA)+
  geom_sf(data=hex, fill=NA, color="white")+
  scale_fill_viridis_c()+
  labs(title = "Densidad Poblacional + grilla hexagonal",
      subtitle = "Ciudad Autónoma de Buenos Aires",
      fill="hab/Ha",
      caption = "Fuente: BA Data")+
  theme_void()
```

Ahora sí, sin sobreescribir la grilla haremos el join espacial de los centroides de los radios a la grilla (UA). 
Es decir, todos los centroides de los radios censales que caigan dentro del mismo hexágono, formarán parte del mismo.

```{r}
hex2 <- st_centroid(radios) %>% st_join(hex)
```
Hasta acá tenemos la info asociada en forma de puntos. 
Veámosla:

```{r}
ggplot()+
  geom_sf(data=hex, fill="grey85") +
  geom_sf(data=hex2, aes(color=DENSIDAD))+
  scale_color_viridis_c()+
  labs(title = "Densidad poblacional por centroide de radios censales",
      subtitle = "Ciudad Autónoma de Buenos Aires",
      color= "hab/Ha",
      caption = "Fuente: BA Data")+  
  theme_void()
```

Vamos a hacer que el hexágono tome como valor el promedio de todos los valores incolucrados.

```{r}
hex3 <- hex2 %>% 
  group_by(index) %>% #agrupamos por ID de hexágono
  summarise(PROM_DENS=mean(DENSIDAD), INSTANCIAS=n()) %>% 
  #resumimos por densidad pero también por cantidad de radios que caen dentro del hexágonos
  as.data.frame() %>% 
  select(-geometry)
```

```{r}
hex_densidad <- left_join(hex3, hex, by="index") #union espacial con la grilla original
```


Entendiendo que los hexágonos con muy pocos valores puede estar sesgados por valores poco representativos, vamos a determinar un umbral. En el caso de que el hexágono registre menos valores que dicho límite inferior, lo diferenciaremos para nuestra correlación.


```{r}
umbral <- 4
```

```{r}
ggplot()+
  geom_sf(data=barrios_CABA, fill="grey85") +
  geom_sf(data=hex_densidad, aes(fill=PROM_DENS, geometry = geometry))+
  geom_sf(data=hex_densidad %>% filter(INSTANCIAS<umbral), aes(geometry=geometry), color="red", alpha=.2)+
  scale_fill_viridis_c() +
  labs(title = "Densidad poblacional por hexágono",
      subtitle = "Ciudad Autónoma de Buenos Aires",
      fill= "hab/Ha",
      caption = "Fuente: BA Data")+  
  theme_void()
```
 
 
 
### RUS 

Para facilitar el trabajo en equipo, este set de datos fue procesado en RUS.Rmd, dentro del mismo repositorio. 
Resume la cantidad de usos que regista cada parcela. 
 
```{r}
RUS <- st_read("data/rus-procesado/RUS-grupo-geo.csv")
```

Convertimos el set de datos de usos en datos geográfico

```{r}
RUS_geo <- RUS %>% 
  st_as_sf(coords = c("X", "Y"), crs = 4326)
```

Lo unimos a nuestra grilla. 

```{r}
hex2 <- RUS_geo %>% st_join(hex)
```

Ahora sí vamos agregar los valores a los hexágonos:

```{r}
hex3 <- hex2 %>% 
  as.data.frame() %>% 
  select(-geometry) %>% 
  group_by(index) %>% #agrupamos por ID de hexágono
  summarise(CANTIDAD_USOS=sum(as.integer(CANTIDAD)), INSTANCIAS=n()) %>% 
  mutate(DIVERSIDAD_USOS=CANTIDAD_USOS/INSTANCIAS)

  #resumimos por cantidad de usos por hexágono
```

```{r}
hex_densidad_usos <- left_join(hex3, hex_densidad, by="index") #union espacial con la grilla que ya tiene la densidad
```


Veamos nuestra grilla con la diversidad de usos:

```{r}
quiebres <- c(0,0.2,0.4,0.6,0.8,1)


ggplot()+
  geom_sf(data=barrios_CABA, fill="grey85") +
  geom_sf(data=hex_densidad_usos, aes(fill=DIVERSIDAD_USOS, geometry = geometry))+
  scale_fill_viridis_c() +
  labs(title = "Diversidad de usos por hexágono",
       subtitle = "Ciudad Autónoma de Buenos Aires",
       fill = " Usos diversos/\n\ cantidad de parcelas",
       caption = "Fuente: GCBA data")+
  theme_void()
```


### Terrenos 2019


```{r}
Terrenos_2019 <- read_sf("data/terrenos-2019/Terrenos_venta_2019.shp") 

Terrenos_2019 <- st_transform(Terrenos_2019, crs=4326) 
```


```{r}
summary(Terrenos_2019)
```

```{r}
dim(Terrenos_2019)
```
```{r}
head(Terrenos_2019)
```


```{r}
Terrenos_2019_seleccion <- select(Terrenos_2019, LATITUD, LONGITUD, M2TOTAL, PRECIOUSD, PRECIOUSDM, BARRIOS, COMUNA, geometry) 
```

```{r}
hex2 <- Terrenos_2019_seleccion %>% st_join(hex)
```

```{r}
hex2 <- hex2 %>% 
  select(PRECIOUSDM, M2TOTAL, PRECIOUSD, geometry, index) %>%
  group_by(index) %>%
  summarise (USD_M2_2019 = mean(PRECIOUSDM), INSTANCIAS_2019=n())
```

```{r}
ggplot()+
  geom_sf(data=hex, fill="grey85") +
  geom_sf(data=hex2, aes(color=USD_M2_2019))+
  geom_sf(data=hex2 %>% filter(INSTANCIAS_2019<umbral), color="red")+
  scale_color_viridis_c()+
  theme_void()
```
```{r}
hex3 <- hex2 %>% 
  group_by(index, INSTANCIAS_2019) %>% #agrupamos por ID de hexágono
  summarise(USD_M2_2019=mean(USD_M2_2019)) %>% 
  as.data.frame() %>%
  select(-geometry)
```

```{r}
hex_promedio_2019<- left_join(hex, hex3, , by="index") #union espacial con la grilla original
```

```{r}
ggplot()+
  geom_sf(data=hex, fill="grey85") +
  geom_sf(data=hex_promedio_2019, aes(fill=USD_M2_2019, geometry=geometry)) +
  geom_sf(data=hex_promedio_2019 %>% filter(INSTANCIAS_2019<umbral), aes(geometry=geometry), color="red", alpha=.2)+
  scale_fill_viridis_c() +
  labs(title = "Precio promedio de los terrenos en venta por hexágonos",
       subtitle = "Ciudad Autónoma de Buenos Aires, 2019",
       fill = "USD/m2",
       caption = "Fuente: GCBA data")+  
  theme_void()
```


### Terrenos 2020


```{r}
Terrenos_2020 <- read_sf("data/terrenos-2020/210517_Terrenos_Vta_Anual2020.shp") 
```

```{r}
Terrenos_2020 <- st_transform(Terrenos_2020, crs=4326) 
```

```{r}
summary(Terrenos_2020)
```


```{r}
dim(Terrenos_2020)
```
```{r}
head(Terrenos_2020)
```

```{r}
Terrenos_2020_seleccion <- select(Terrenos_2020, PRECIOUSD, DOLARM2, BARRIO, COMUNA_, geometry) 
```

```{r}
hex2 <- Terrenos_2020_seleccion %>% st_join(hex)
```

```{r}
hex2 <- select(hex2, geometry, DOLARM2, PRECIOUSD, BARRIO, COMUNA_,index)%>%
  group_by(index)%>%
  summarise (USD_M2_2020 = mean(DOLARM2), INSTANCIAS_2020=n())
```

```{r}
ggplot()+
  geom_sf(data=hex, fill="grey85") +
  geom_sf(data=hex2, aes(color=USD_M2_2020))+
  geom_sf(data=hex2 %>% filter(INSTANCIAS_2020<umbral), color="red")+
  scale_color_viridis_c()+
  theme_void()
```

```{r}
hex3 <- hex2 %>% 
  group_by(index, INSTANCIAS_2020) %>% #agrupamos por ID de hexágono
  summarise(USD_M2_2020=mean(USD_M2_2020)) %>% 
  as.data.frame() %>%
  select(-geometry)
```

```{r}
hex_promedio_2020<- left_join(hex3, hex, by="index") #union espacial con la grilla original
```

```{r}
ggplot()+
  geom_sf(data=hex, fill="grey85") +
  geom_sf(data=hex_promedio_2020, aes(fill=USD_M2_2020, geometry=geometry)) +
  geom_sf(data=hex_promedio_2020 %>% filter(INSTANCIAS_2020<umbral), aes(geometry=geometry), color="red", alpha=.2)+
  scale_fill_viridis_c() +
  labs(title = "Precio promedio de los terrenos en venta por hexágonos",
       subtitle = "Ciudad Autónoma de Buenos Aires, 2020",
       fill = "USD/m2",
       caption = "Fuente: GCBA data")+  
  theme_void()
```


### Variación porcentual interanual


Vamos a procedes a unir a través de nuestro ID de hexágono (index): 
    
    - Densidades poblacionales
    - Diversidad de uso del suelo
    - USD/m2 2019 y 2020 para el cálculo de la variación interanual
    

```{r}
hex_promedio_2019 <- hex_promedio_2019 %>% 
  as.data.frame() %>% 
  select(index, USD_M2_2019, INSTANCIAS_2019) %>% 
  filter (INSTANCIAS_2019>=umbral)

hex_promedio_2020 <- hex_promedio_2020 %>% 
  as.data.frame() %>% 
  select(index, USD_M2_2020, INSTANCIAS_2020) %>% 
  filter (INSTANCIAS_2020>=umbral) 
  
hexagonos <- hex_densidad_usos %>% 
  left_join(hex_promedio_2019, by="index") %>% 
  left_join(hex_promedio_2020, by="index") %>% 
  mutate(VARIACION=(USD_M2_2020/USD_M2_2019)-1)
```

```{r}
ggplot()+
  geom_sf(data=hex, fill="grey85") +
  geom_sf(data=hexagonos %>% filter(VARIACION>0), aes(geometry=geometry), fill="darkgreen", alpha=.5) +
  geom_sf(data=hexagonos %>% filter(VARIACION<0), aes(geometry=geometry), fill="red", alpha=.5) +
  scale_fill_viridis_c() +
  labs(title = " Variación del precio promedio de \n los terrenos en venta por hexágonos",
       subtitle = "Ciudad Autónoma de Buenos Aires, 2020",
       caption = "Fuente: GCBA data")+  
  theme_void()
```



```{r}
ggplot(hexagonos, aes(x=PROM_DENS, y=VARIACION)) +
  geom_point()+
  geom_smooth(method=lm,  linetype="dashed",
             color="darkred")+
  theme_minimal()
```

```{r}
ggplot(hexagonos, aes(x=DIVERSIDAD_USOS, y=VARIACION)) +
  geom_point()+
  geom_smooth(method=lm,  linetype="dashed",
             color="darkred")+
 # ylim(-50, 300)+
  theme_minimal()
```



